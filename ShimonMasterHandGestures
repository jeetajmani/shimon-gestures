#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import csv
import copy
import argparse
import itertools
import threading
import time
import math
from collections import Counter, deque

import cv2 as cv
import numpy as np
import mediapipe as mp
from pythonosc import udp_client

# ===================== OSC / Music endpoints =====================
HOST = "192.168.1.1"     # <— set your robot IP
MUSIC_PORT = 9010        # /arm endpoint as in your example
OSC_ARM_PATH = "/arm"    # sends [midi_note, velocity]

# Playback tempo
BPM_DEFAULT = 120.0

# ===================== Hand indices & helpers =====================
WRIST = 0
TH_MCP, TH_IP, TH_TIP = 2, 3, 4
IX_MCP, IX_PIP, IX_DIP, IX_TIP = 5, 6, 7, 8
MI_MCP, MI_PIP, MI_DIP, MI_TIP = 9, 10, 11, 12
RI_MCP, RI_PIP, RI_DIP, RI_TIP = 13, 14, 15, 16
PI_MCP, PI_PIP, PI_DIP, PI_TIP = 17, 18, 19, 20

def is_spin_cw(label: str) -> bool:
    t = label.strip().lower()
    return ("clockwise" in t) or ("cw" == t) or (" cw" in t) or (t.endswith(" cw"))

def is_spin_ccw(label: str) -> bool:
    t = label.strip().lower()
    return ("counterclockwise" in t) or ("counter clockwise" in t) or ("ccw" == t) or (" ccw" in t) or (t.endswith(" ccw"))

# ===================== Music player =====================
class MusicPlayer:
    def __init__(self, host=HOST, port=MUSIC_PORT, path=OSC_ARM_PATH,
                 bpm=BPM_DEFAULT, velocity=100):
        self.client = udp_client.SimpleUDPClient(host, port)
        self.path = path
        self._bpm = float(bpm)
        self._vel = int(velocity)
        self._mode = "arp_cmaj"
        self._stop_evt = threading.Event()
        self._lock = threading.Lock()
        self._resume_to_cmaj_next = False

        self._thr = threading.Thread(target=self._loop, daemon=True)
        self._thr.start()

    def set_mode(self, mode: str):
        with self._lock:
            if mode not in ("arp_cmaj", "arp_cmin", "arp_gmaj", "arp_caug", "arp_cdim", "stopped"):
                return
            if mode != self._mode:
                print(f"[Player] mode -> {mode}")
            self._mode = mode

    def pause(self):
        with self._lock:
            self._mode = "stopped"
            self._resume_to_cmaj_next = True
            print("[Player] STOP")

    def resume(self):
        with self._lock:
            if self._mode == "stopped":
                self._mode = "arp_cmaj"
                self._resume_to_cmaj_next = False
                print("[Player] RESUME → arp_cmaj")

    def _arp_updown(self, root: int, intervals=(0, 4, 7), octaves=1):
        notes_up = []
        for o in range(octaves):
            r = root + 12 * o
            notes_up += [r + i for i in intervals]
        notes_up.append(root + 12 * octaves)
        return notes_up + list(reversed(notes_up[:-1]))

    def _sequence_for_mode(self, mode: str):
        if mode == "arp_cmaj": return self._arp_updown(60, (0, 4, 7), 1)
        if mode == "arp_cmin": return self._arp_updown(60, (0, 3, 7), 1)
        if mode == "arp_gmaj": return self._arp_updown(67, (0, 4, 7), 1)
        if mode == "arp_caug": return self._arp_updown(60, (0, 4, 8), 1)
        if mode == "arp_cdim": return self._arp_updown(60, (0, 3, 6), 1)
        return []

    def _loop(self):
        idx = 0
        while not self._stop_evt.is_set():
            with self._lock:
                mode = self._mode
                bpm  = self._bpm
                vel  = self._vel
                seq  = self._sequence_for_mode(mode)
            beat = 60.0 / bpm
            if mode == "stopped" or not seq:
                time.sleep(0.05)
                continue
            note = seq[idx]
            self._strike(note, vel)
            idx = (idx + 1) % len(seq)
            time.sleep(beat)
        print("[Player] stopped thread")

    def _strike(self, midi_note: int, velocity: int):
        try:
            self.client.send_message(self.path, [int(midi_note), int(velocity)])
        except Exception as e:
            print("[OSC ERROR]", e)

    def shutdown(self):
        self._stop_evt.set()
        if self._thr.is_alive():
            self._thr.join(timeout=1.0)

# ===================== Gesture helpers =====================
def _scale_from_points(pts):
    x, y, w, h = cv.boundingRect(pts.astype(np.int32))
    return (w**2 + h**2) ** 0.5 + 1e-6

def _pip_angle(pts, mcp, pip, dip):
    v1 = pts[mcp] - pts[pip]
    v2 = pts[dip] - pts[pip]
    a = np.linalg.norm(v1); b = np.linalg.norm(v2)
    if a == 0 or b == 0: return 180.0
    cosang = np.clip(np.dot(v1, v2) / (a*b), -1.0, 1.0)
    return math.degrees(math.acos(cosang))

def _curl_score(pts, mcp, pip, dip):
    ang = _pip_angle(pts, mcp, pip, dip)
    return float(np.clip((180.0 - ang) / 120.0, 0.0, 1.0))

def _others_mostly_folded(pts, tol=0.45):
    curls = [_curl_score(pts, IX_MCP, IX_PIP, IX_DIP),
             _curl_score(pts, MI_MCP, MI_PIP, MI_DIP),
             _curl_score(pts, RI_MCP, RI_PIP, RI_DIP),
             _curl_score(pts, PI_MCP, PI_PIP, PI_DIP)]
    return (sum(c >= tol for c in curls) >= 3)

def _thumb_extended_and_dir(pts):
    v1 = pts[TH_MCP] - pts[TH_IP]
    v2 = pts[TH_TIP] - pts[TH_IP]
    a, b = np.linalg.norm(v1), np.linalg.norm(v2)
    ang = 180.0 if a == 0 or b == 0 else math.degrees(math.acos(np.clip(np.dot(v1,v2)/(a*b), -1.0, 1.0)))
    dir_vec = pts[TH_TIP] - pts[TH_MCP]
    n = np.linalg.norm(dir_vec)
    dir_vec = dir_vec / n if n > 0 else np.array([0.0, 0.0])
    return (ang > 150.0, -dir_vec[1], dir_vec)

def is_thumbs_up(landmark_list_xy):
    pts = np.asarray(landmark_list_xy, dtype=np.float32)
    s = _scale_from_points(pts)
    if not _others_mostly_folded(pts): return False
    th_ext, upness, dir_vec = _thumb_extended_and_dir(pts)
    return th_ext and upness > 0.35

def is_thumbs_down(landmark_list_xy):
    pts = np.asarray(landmark_list_xy, dtype=np.float32)
    s = _scale_from_points(pts)
    if not _others_mostly_folded(pts): return False
    th_ext, upness, dir_vec = _thumb_extended_and_dir(pts)
    return th_ext and upness < -0.35

def _finger_extended(pts, mcp, pip, dip, tip, thres_deg=160):
    return _pip_angle(pts, mcp, pip, dip) > thres_deg

def is_open_palm(landmark_list_xy):
    pts = np.asarray(landmark_list_xy, dtype=np.float32)
    s = _scale_from_points(pts)
    idx = _finger_extended(pts, IX_MCP, IX_PIP, IX_DIP, IX_TIP)
    mid = _finger_extended(pts, MI_MCP, MI_PIP, MI_DIP, MI_TIP)
    rin = _finger_extended(pts, RI_MCP, RI_PIP, RI_DIP, RI_TIP)
    pin = _finger_extended(pts, PI_MCP, PI_PIP, PI_DIP, PI_TIP)
    return idx and mid and rin and pin

# ===================== UI / HUD =====================
def put_hud(img, text, y, color=(255,255,255)):
    cv.putText(img, text, (10, y), cv.FONT_HERSHEY_SIMPLEX, 0.8, (0,0,0), 3, cv.LINE_AA)
    cv.putText(img, text, (10, y), cv.FONT_HERSHEY_SIMPLEX, 0.8, color, 1, cv.LINE_AA)

# ===================== Main =====================
def main():
    from model import KeyPointClassifier, PointHistoryClassifier
    from utils import CvFpsCalc

    cap = cv.VideoCapture(0)
    cap.set(cv.CAP_PROP_FRAME_WIDTH, 960)
    cap.set(cv.CAP_PROP_FRAME_HEIGHT, 540)

    mp_hands = mp.solutions.hands
    hands = mp_hands.Hands(max_num_hands=2, min_detection_confidence=0.7, min_tracking_confidence=0.5)
    kpc = KeyPointClassifier()
    phc = PointHistoryClassifier()

    with open('model/keypoint_classifier/keypoint_classifier_label.csv', encoding='utf-8-sig') as f:
        key_labels = [row[0] for row in csv.reader(f)]
    with open('model/point_history_classifier/point_history_classifier_label.csv', encoding='utf-8-sig') as f:
        hist_labels = [row[0] for row in csv.reader(f)]

    fps_calc = CvFpsCalc(buffer_len=10)

    player = MusicPlayer(host=HOST, port=MUSIC_PORT, path=OSC_ARM_PATH, bpm=BPM_DEFAULT, velocity=100)
    player.set_mode("arp_cmaj")

    stop_request_started_at = None

    try:
        while True:
            fps = fps_calc.get()
            if cv.waitKey(1) & 0xFF in (27, ord('q'), ord('Q')):
                break

            ok, frame = cap.read()
            if not ok:
                break
            frame = cv.flip(frame, 1)
            debug = frame.copy()

            rgb = cv.cvtColor(frame, cv.COLOR_BGR2RGB)
            results = hands.process(rgb)

            want_stop = False
            switch_to = None

            if results.multi_hand_landmarks:
                for hand_lms, handedness in zip(results.multi_hand_landmarks, results.multi_handedness):
                    label = handedness.classification[0].label
                    pts = [[int(l.x * frame.shape[1]), int(l.y * frame.shape[0])] for l in hand_lms.landmark]
                    pre = [p for sub in pts for p in sub]
                    sid = kpc(pre)
                    sign_txt = key_labels[sid]

                    if is_open_palm(pts):
                        sign_txt = "Open Hand"
                        want_stop = True
                    elif is_thumbs_up(pts):
                        sign_txt = "Thumbs Up"
                        switch_to = "arp_cdim"
                    elif is_thumbs_down(pts):
                        sign_txt = "Thumbs Down"
                        switch_to = "arp_cmin"

                    cv.putText(debug, f"{label}:{sign_txt}", (10, 90), cv.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 1)

            now = time.time()
            if want_stop:
                if stop_request_started_at is None:
                    stop_request_started_at = now
                elapsed = now - stop_request_started_at
                if elapsed >= 2.0:
                    player.pause()
                    put_hud(debug, "PLAYBACK: STOP", 120, (0,0,255))
                    stop_request_started_at = None
                else:
                    put_hud(debug, f"Stopping in {2.0 - elapsed:.1f}s", 120, (0,200,255))
            else:
                stop_request_started_at = None

            if not want_stop and switch_to:
                player.set_mode(switch_to)
                put_hud(debug, f"MODE: {switch_to}", 150, (0,255,0))

            put_hud(debug, f"FPS: {fps}", 30)
            cv.imshow("Hand Gestures → Arpeggio Control", debug)

    finally:
        player.shutdown()
        cap.release()
        cv.destroyAllWindows()

if __name__ == "__main__":
    main()
